// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: game.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createGame = `-- name: CreateGame :one
INSERT INTO games (created_by) 
VALUES ($1) 
RETURNING game_id, status, created_by, number_of_players, current_turn, current_player_number, start_time, last_action_time, end_time
`

func (q *Queries) CreateGame(ctx context.Context, createdBy int64) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame, createdBy)
	var i Game
	err := row.Scan(
		&i.GameID,
		&i.Status,
		&i.CreatedBy,
		&i.NumberOfPlayers,
		&i.CurrentTurn,
		&i.CurrentPlayerNumber,
		&i.StartTime,
		&i.LastActionTime,
		&i.EndTime,
	)
	return i, err
}

const declareWinner = `-- name: DeclareWinner :one
SELECT player_game_id, player_number, player_score FROM player_game 
WHERE game_id = $1 
ORDER BY player_score DESC LIMIT 1
`

type DeclareWinnerRow struct {
	PlayerGameID int64         `json:"player_game_id"`
	PlayerNumber sql.NullInt32 `json:"player_number"`
	PlayerScore  int32         `json:"player_score"`
}

// Declare the winner of the game
func (q *Queries) DeclareWinner(ctx context.Context, gameID int64) (DeclareWinnerRow, error) {
	row := q.db.QueryRowContext(ctx, declareWinner, gameID)
	var i DeclareWinnerRow
	err := row.Scan(&i.PlayerGameID, &i.PlayerNumber, &i.PlayerScore)
	return i, err
}

const endGame = `-- name: EndGame :exec
UPDATE games SET status = 'completed', end_time = NOW() 
WHERE game_id = $1
`

func (q *Queries) EndGame(ctx context.Context, gameID int64) error {
	_, err := q.db.ExecContext(ctx, endGame, gameID)
	return err
}

const getGameByID = `-- name: GetGameByID :one
SELECT game_id, status, created_by, number_of_players, current_turn, current_player_number, start_time, last_action_time, end_time FROM games 
WHERE game_id = $1
`

func (q *Queries) GetGameByID(ctx context.Context, gameID int64) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameByID, gameID)
	var i Game
	err := row.Scan(
		&i.GameID,
		&i.Status,
		&i.CreatedBy,
		&i.NumberOfPlayers,
		&i.CurrentTurn,
		&i.CurrentPlayerNumber,
		&i.StartTime,
		&i.LastActionTime,
		&i.EndTime,
	)
	return i, err
}

const getGameByPlayerGameID = `-- name: GetGameByPlayerGameID :one
SELECT games.game_id, status, created_by, number_of_players, current_turn, current_player_number, start_time, last_action_time, end_time, player_game_id, player_id, player_game.game_id, player_number, player_score, player_status FROM games 
INNER JOIN 
  player_game ON games.game_id = player_game.game_id
WHERE 
  player_game.player_game_id = $1
`

type GetGameByPlayerGameIDRow struct {
	GameID              int64         `json:"game_id"`
	Status              string        `json:"status"`
	CreatedBy           int64         `json:"created_by"`
	NumberOfPlayers     int32         `json:"number_of_players"`
	CurrentTurn         int32         `json:"current_turn"`
	CurrentPlayerNumber sql.NullInt32 `json:"current_player_number"`
	StartTime           time.Time     `json:"start_time"`
	LastActionTime      sql.NullTime  `json:"last_action_time"`
	EndTime             sql.NullTime  `json:"end_time"`
	PlayerGameID        int64         `json:"player_game_id"`
	PlayerID            int64         `json:"player_id"`
	GameID_2            int64         `json:"game_id_2"`
	PlayerNumber        sql.NullInt32 `json:"player_number"`
	PlayerScore         int32         `json:"player_score"`
	PlayerStatus        string        `json:"player_status"`
}

func (q *Queries) GetGameByPlayerGameID(ctx context.Context, playerGameID int64) (GetGameByPlayerGameIDRow, error) {
	row := q.db.QueryRowContext(ctx, getGameByPlayerGameID, playerGameID)
	var i GetGameByPlayerGameIDRow
	err := row.Scan(
		&i.GameID,
		&i.Status,
		&i.CreatedBy,
		&i.NumberOfPlayers,
		&i.CurrentTurn,
		&i.CurrentPlayerNumber,
		&i.StartTime,
		&i.LastActionTime,
		&i.EndTime,
		&i.PlayerGameID,
		&i.PlayerID,
		&i.GameID_2,
		&i.PlayerNumber,
		&i.PlayerScore,
		&i.PlayerStatus,
	)
	return i, err
}

const getGameScores = `-- name: GetGameScores :many
SELECT 
  users.id AS id,
  users.username,
  player_game.player_score
FROM 
  player_game
INNER JOIN 
  users ON player_game.player_id = users.id
WHERE 
  player_game.game_id = $1
`

type GetGameScoresRow struct {
	ID          int64  `json:"id"`
	Username    string `json:"username"`
	PlayerScore int32  `json:"player_score"`
}

func (q *Queries) GetGameScores(ctx context.Context, gameID int64) ([]GetGameScoresRow, error) {
	rows, err := q.db.QueryContext(ctx, getGameScores, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGameScoresRow{}
	for rows.Next() {
		var i GetGameScoresRow
		if err := rows.Scan(&i.ID, &i.Username, &i.PlayerScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveGames = `-- name: ListActiveGames :many
SELECT game_id, status, created_by, number_of_players, current_turn, current_player_number, start_time, last_action_time, end_time FROM games 
LIMIT $1 OFFSET $2
`

type ListActiveGamesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveGames(ctx context.Context, arg ListActiveGamesParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, listActiveGames, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.GameID,
			&i.Status,
			&i.CreatedBy,
			&i.NumberOfPlayers,
			&i.CurrentTurn,
			&i.CurrentPlayerNumber,
			&i.StartTime,
			&i.LastActionTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamePlayers = `-- name: ListGamePlayers :many
SELECT player_game_id, player_id, game_id, player_number, player_score, player_status FROM player_game 
WHERE game_id = $1 
ORDER BY player_number ASC
LIMIT $2 OFFSET $3
`

type ListGamePlayersParams struct {
	GameID int64 `json:"game_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListGamePlayers(ctx context.Context, arg ListGamePlayersParams) ([]PlayerGame, error) {
	rows, err := q.db.QueryContext(ctx, listGamePlayers, arg.GameID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PlayerGame{}
	for rows.Next() {
		var i PlayerGame
		if err := rows.Scan(
			&i.PlayerGameID,
			&i.PlayerID,
			&i.GameID,
			&i.PlayerNumber,
			&i.PlayerScore,
			&i.PlayerStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startGame = `-- name: StartGame :exec
UPDATE games
SET status = 'active', number_of_players = $1, current_turn = 1, current_player_number = 1
WHERE game_id = $2
`

type StartGameParams struct {
	NumberOfPlayers int32 `json:"number_of_players"`
	GameID          int64 `json:"game_id"`
}

func (q *Queries) StartGame(ctx context.Context, arg StartGameParams) error {
	_, err := q.db.ExecContext(ctx, startGame, arg.NumberOfPlayers, arg.GameID)
	return err
}

const updateGameState = `-- name: UpdateGameState :exec
UPDATE games
SET current_turn = $2, current_player_number = $3, last_action_time = NOW()
WHERE game_id = $1
`

type UpdateGameStateParams struct {
	GameID              int64         `json:"game_id"`
	CurrentTurn         int32         `json:"current_turn"`
	CurrentPlayerNumber sql.NullInt32 `json:"current_player_number"`
}

func (q *Queries) UpdateGameState(ctx context.Context, arg UpdateGameStateParams) error {
	_, err := q.db.ExecContext(ctx, updateGameState, arg.GameID, arg.CurrentTurn, arg.CurrentPlayerNumber)
	return err
}

const updateGameStatus = `-- name: UpdateGameStatus :exec
UPDATE games SET status = $1 
WHERE game_id = $2
`

type UpdateGameStatusParams struct {
	Status string `json:"status"`
	GameID int64  `json:"game_id"`
}

func (q *Queries) UpdateGameStatus(ctx context.Context, arg UpdateGameStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateGameStatus, arg.Status, arg.GameID)
	return err
}
