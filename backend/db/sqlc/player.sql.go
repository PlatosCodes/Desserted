// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: player.sql

package db

import (
	"context"
	"database/sql"
)

const addPlayerToGame = `-- name: AddPlayerToGame :exec

INSERT INTO players (user_id, game_id, hand_cards, played_cards)
VALUES ($1, $2, $3, $4)
`

type AddPlayerToGameParams struct {
	UserID      sql.NullInt64  `json:"user_id"`
	GameID      sql.NullInt64  `json:"game_id"`
	HandCards   sql.NullString `json:"hand_cards"`
	PlayedCards sql.NullString `json:"played_cards"`
}

// player.sql
// Add player to a game
func (q *Queries) AddPlayerToGame(ctx context.Context, arg AddPlayerToGameParams) error {
	_, err := q.db.ExecContext(ctx, addPlayerToGame,
		arg.UserID,
		arg.GameID,
		arg.HandCards,
		arg.PlayedCards,
	)
	return err
}

const getPlayersInGame = `-- name: GetPlayersInGame :many
SELECT user_id, game_id, score, hand_cards, played_cards FROM players WHERE game_id = $1
`

// Get players in a game
func (q *Queries) GetPlayersInGame(ctx context.Context, gameID sql.NullInt64) ([]Player, error) {
	rows, err := q.db.QueryContext(ctx, getPlayersInGame, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.UserID,
			&i.GameID,
			&i.Score,
			&i.HandCards,
			&i.PlayedCards,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayerScore = `-- name: UpdatePlayerScore :exec
UPDATE players SET score = $1 WHERE user_id = $2 AND game_id = $3
`

type UpdatePlayerScoreParams struct {
	Score  sql.NullInt32 `json:"score"`
	UserID sql.NullInt64 `json:"user_id"`
	GameID sql.NullInt64 `json:"game_id"`
}

// Update player's score
func (q *Queries) UpdatePlayerScore(ctx context.Context, arg UpdatePlayerScoreParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayerScore, arg.Score, arg.UserID, arg.GameID)
	return err
}
