Ok excellent. Here is my updated codebase. I'd like you to again extends the functionality of my frontend to be more complete in regards to the functionality of my backend. In particular, I need updated src/views/. 

{
  "swagger": "2.0",
  "info": {
    "title": "Desserted API",
    "version": "1.0",
    "contact": {
      "name": "Alex Merola",
      "url": "https://github.com/PlatosCodes",
      "email": "codingplato@gmail.com"
    }
  },
  "tags": [
    {
      "name": "Desserted"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/accept_friend_request": {
      "post": {
        "summary": "Accept a friend request",
        "description": "Use this API to accept a friend request",
        "operationId": "Desserted_AcceptFriendRequest",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbAcceptFriendRequestRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/accept_game_invite": {
      "post": {
        "summary": "Accept invite the game",
        "description": "Use this API to accept an invitation to a game",
        "operationId": "Desserted_AcceptGameInvite",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbAcceptGameInviteRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/check_session": {
      "post": {
        "summary": "Check user session",
        "description": "Use this API to check session for a user",
        "operationId": "Desserted_CheckUserSession",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbCheckUserSessionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbCheckUserSessionRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/create_friendship": {
      "post": {
        "summary": "Create new friendship",
        "description": "Use this API to create a new friendship",
        "operationId": "Desserted_CreateFriendship",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbCreateFriendshipResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbCreateFriendshipRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/create_game": {
      "post": {
        "summary": "Create new game",
        "description": "Use this API to create a new game",
        "operationId": "Desserted_CreateGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbCreateGameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbCreateGameRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/create_user": {
      "post": {
        "summary": "Create new user",
        "description": "Use this API to create a new user",
        "operationId": "Desserted_CreateUser",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbCreateUserResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbCreateUserRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/draw_card": {
      "post": {
        "summary": "Draw a card",
        "description": "Use this API to draw a card",
        "operationId": "Desserted_DrawCard",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbDrawCardResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbDrawCardRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/get_player_game/{playerGameId}": {
      "get": {
        "summary": "Get the player's game data",
        "description": "Use this API to get data for a player's game",
        "operationId": "Desserted_GetPlayerGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbGetPlayerGameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "playerGameId",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/get_player_hand": {
      "get": {
        "summary": "Get the player's hand",
        "description": "Use this API to get a player's hand",
        "operationId": "Desserted_GetPlayerHand",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbGetPlayerHandResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "playerGameId",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/invite_player_to_game": {
      "post": {
        "summary": "Invite player to the game",
        "description": "Use this API to invite a player to the game",
        "operationId": "Desserted_InvitePlayerToGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbInvitePlayerToGameRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/list_friend_requests/{userId}": {
      "get": {
        "summary": "List a user's friend requests",
        "description": "Use this API to list a user's pending friend requests",
        "operationId": "Desserted_ListFriendRequests",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbListFriendRequestsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/list_game_players": {
      "get": {
        "summary": "List the game's players",
        "description": "Use this API to list the players of the game",
        "operationId": "Desserted_ListGamePlayers",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbListGamePlayersResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "gameId",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/list_user_friends": {
      "post": {
        "summary": "List a user's friends",
        "description": "Use this API to list a user's friends",
        "operationId": "Desserted_ListUserFriends",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbListUserFriendsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbListUserFriendsRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/login_user": {
      "post": {
        "summary": "Login a user",
        "description": "Use this API to login a user",
        "operationId": "Desserted_LoginUser",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbLoginUserResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbLoginUserRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/logout": {
      "post": {
        "summary": "Logout a user",
        "description": "Use this API to logout a user",
        "operationId": "Desserted_Logout",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbLogoutRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/play_dessert": {
      "post": {
        "summary": "Play a dessert",
        "description": "Use this API to play a dessert",
        "operationId": "Desserted_PlayDessert",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbPlayDessertResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbPlayDessertRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/start_game": {
      "post": {
        "summary": "Start the game",
        "description": "Use this API to start a game",
        "operationId": "Desserted_StartGame",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbStartGameResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbStartGameRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    },
    "/v1/update_user": {
      "patch": {
        "summary": "Update a user",
        "description": "Use this API to update a user",
        "operationId": "Desserted_UpdateUser",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/pbUpdateUserResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pbUpdateUserRequest"
            }
          }
        ],
        "tags": [
          "Desserted"
        ]
      }
    }
  },
  "definitions": {
    "pbAcceptFriendRequestRequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string",
          "format": "int64",
          "title": "ID of the user accepting the request"
        },
        "friendshipId": {
          "type": "string",
          "format": "int64",
          "title": "ID of the friendship to accept"
        }
      }
    },
    "pbAcceptGameInviteRequest": {
      "type": "object",
      "properties": {
        "inviteeUsername": {
          "type": "string"
        },
        "gameId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "pbCheckUserSessionRequest": {
      "type": "object",
      "properties": {
        "sessionId": {
          "type": "string"
        }
      }
    },
    "pbCheckUserSessionResponse": {
      "type": "object",
      "properties": {
        "isAuthenticated": {
          "type": "boolean"
        }
      }
    },
    "pbCreateFriendshipRequest": {
      "type": "object",
      "properties": {
        "frienderId": {
          "type": "string",
          "format": "int64"
        },
        "friendeeUsername": {
          "type": "string"
        }
      }
    },
    "pbCreateFriendshipResponse": {
      "type": "object",
      "properties": {
        "friendship": {
          "$ref": "#/definitions/pbFriend"
        }
      }
    },
    "pbCreateGameRequest": {
      "type": "object",
      "properties": {
        "createdBy": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "pbCreateGameResponse": {
      "type": "object",
      "properties": {
        "game": {
          "$ref": "#/definitions/pbGame"
        }
      }
    },
    "pbCreateUserRequest": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      }
    },
    "pbCreateUserResponse": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/pbUser"
        }
      }
    },
    "pbDrawCardRequest": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string",
          "format": "int64"
        },
        "playerGameId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "pbDrawCardResponse": {
      "type": "object",
      "properties": {
        "cardId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "pbFriend": {
      "type": "object",
      "properties": {
        "friendshipId": {
          "type": "string",
          "format": "int64"
        },
        "frienderId": {
          "type": "string",
          "format": "int64"
        },
        "friendeeId": {
          "type": "string",
          "format": "int64"
        },
        "friendedAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "pbFriendRequest": {
      "type": "object",
      "properties": {
        "friendshipId": {
          "type": "string",
          "format": "int64"
        },
        "frienderId": {
          "type": "string",
          "format": "int64"
        },
        "frienderUsername": {
          "type": "string"
        },
        "friendedAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "pbGame": {
      "type": "object",
      "properties": {
        "gameId": {
          "type": "string",
          "format": "int64"
        },
        "status": {
          "type": "string"
        },
        "createdBy": {
          "type": "string",
          "format": "int64"
        },
        "startTime": {
          "type": "string",
          "format": "date-time"
        },
        "endTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "pbGetPlayerGameResponse": {
      "type": "object",
      "properties": {
        "player": {
          "$ref": "#/definitions/pbPlayerGame"
        }
      }
    },
    "pbGetPlayerHandResponse": {
      "type": "object",
      "properties": {
        "playerHand": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/pbPlayerHand"
          }
        }
      }
    },
    "pbInvitePlayerToGameRequest": {
      "type": "object",
      "properties": {
        "inviterPlayerId": {
          "type": "string",
          "format": "int64"
        },
        "inviteeUsername": {
          "type": "string"
        },
        "gameId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "pbListFriendRequestsResponse": {
      "type": "object",
      "properties": {
        "friendRequests": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/pbFriendRequest"
          }
        }
      }
    },
    "pbListGamePlayersResponse": {
      "type": "object",
      "properties": {
        "players": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/pbPlayerGame"
          }
        }
      }
    },
    "pbListUserFriendsRequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string",
          "format": "int64",
          "title": "The user ID for whom to list friends"
        },
        "limit": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of friendships to return"
        },
        "offset": {
          "type": "integer",
          "format": "int32",
          "title": "Offset for pagination"
        }
      },
      "title": "Request for listing user friendships"
    },
    "pbListUserFriendsResponse": {
      "type": "object",
      "properties": {
        "friendships": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/pbFriend"
          },
          "title": "List of friendships"
        }
      },
      "title": "Response for listing user friendships"
    },
    "pbLoginUserRequest": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      }
    },
    "pbLoginUserResponse": {
      "type": "object",
      "properties": {
        "sessionId": {
          "type": "string"
        },
        "accessToken": {
          "type": "string"
        },
        "accessTokenExpiresAt": {
          "type": "string",
          "format": "date-time"
        },
        "refreshToken": {
          "type": "string"
        },
        "refreshTokenExpiresAt": {
          "type": "string",
          "format": "date-time"
        },
        "user": {
          "$ref": "#/definitions/pbUser"
        }
      }
    },
    "pbLogoutRequest": {
      "type": "object",
      "properties": {
        "sessionId": {
          "type": "string"
        }
      }
    },
    "pbPlayDessertRequest": {
      "type": "object",
      "properties": {
        "playerGameId": {
          "type": "string",
          "format": "int64"
        },
        "dessertName": {
          "type": "string"
        },
        "cardIds": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "pbPlayDessertResponse": {
      "type": "object",
      "properties": {
        "dessertPlayedId": {
          "type": "string",
          "format": "int64"
        },
        "playerGame": {
          "$ref": "#/definitions/pbPlayerGame"
        },
        "gameOver": {
          "type": "boolean"
        }
      }
    },
    "pbPlayerGame": {
      "type": "object",
      "properties": {
        "playerGame": {
          "type": "string",
          "format": "int64"
        },
        "playerId": {
          "type": "string",
          "format": "int64"
        },
        "gameId": {
          "type": "string",
          "format": "int64"
        },
        "playerScore": {
          "type": "integer",
          "format": "int32"
        },
        "playerStatus": {
          "type": "string"
        }
      }
    },
    "pbPlayerHand": {
      "type": "object",
      "properties": {
        "playerHandId": {
          "type": "string",
          "format": "int64"
        },
        "playerGameId": {
          "type": "string",
          "format": "int64"
        },
        "cardId": {
          "type": "string",
          "format": "int64"
        },
        "cardName": {
          "type": "string"
        }
      }
    },
    "pbStartGameRequest": {
      "type": "object",
      "properties": {
        "creatorId": {
          "type": "string",
          "format": "int64"
        },
        "gameId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "pbStartGameResponse": {
      "type": "object",
      "properties": {
        "game": {
          "$ref": "#/definitions/pbGame"
        }
      }
    },
    "pbUpdateUserRequest": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      }
    },
    "pbUpdateUserResponse": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/pbUser"
        }
      }
    },
    "pbUser": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "int64"
        },
        "username": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "passwordChangedAt": {
          "type": "string",
          "format": "date-time"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    }
  }
}

syntax = "proto3";

package pb;

import "google/api/annotations.proto";
import "rpc_create_user.proto";
import "rpc_login_user.proto";
import "rpc_logout.proto";
import "rpc_check_session.proto";
import "rpc_update_user.proto";
import "rpc_create_friendship.proto";
import "rpc_list_user_friendships.proto";
import "rpc_list_friend_requests.proto";
import "rpc_accept_friend_request.proto";
import "rpc_create_game.proto";
import "rpc_invite_player_to_game.proto";
import "rpc_accept_game_invite.proto";
// import "rpc_add_player_to_game.proto";
import "rpc_list_game_players.proto";
import "rpc_get_player_game.proto";
import "rpc_start_game.proto";
import "rpc_get_player_hand.proto";
import "rpc_play_dessert.proto";
import "rpc_draw_card.proto";
import "google/protobuf/empty.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option go_package = "github.com/PlatosCodes/desserted/backend/pb";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "Desserted API";
    version: "1.0";
    contact: {
      name: "Alex Merola";
      url: "https://github.com/PlatosCodes";
      email: "codingplato@gmail.com";
    };
  };
};

service Desserted {
      // Creates a new user
    rpc CreateUser (CreateUserRequest) returns (CreateUserResponse) {
        option (google.api.http) = {    
            post: "/v1/create_user"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
          description: "Use this API to create a new user";
          summary: "Create new user";
        };
    };
    // Logs in a user
    rpc LoginUser (LoginUserRequest) returns (LoginUserResponse) {
        option (google.api.http) = {    
            post: "/v1/login_user"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
          description: "Use this API to login a user";
          summary: "Login a user";
        };
    };
    // Logs out a user
    rpc Logout (LogoutRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
          post: "/v1/logout"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to logout a user";
        summary: "Logout a user";
      };
    };
    rpc CheckUserSession (CheckUserSessionRequest) returns (CheckUserSessionResponse) {
      option (google.api.http) = {
          post: "/v1/check_session"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to check session for a user";
        summary: "Check user session";
      };
    };
    // Updates a user's password
    rpc UpdateUser (UpdateUserRequest) returns (UpdateUserResponse) {
      option (google.api.http) = {    
          patch: "/v1/update_user"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to update a user";
        summary: "Update a user";
      };
    };
    rpc CreateFriendship (CreateFriendshipRequest) returns (CreateFriendshipResponse) {
      option (google.api.http) = {    
          post: "/v1/create_friendship"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to create a new friendship";
        summary: "Create new friendship";
      };
    };
    rpc ListUserFriends (ListUserFriendsRequest) returns (ListUserFriendsResponse) {
      option (google.api.http) = {    
          post: "/v1/list_user_friends"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to list a user's friends";
        summary: "List a user's friends";
      };
    };
    rpc ListFriendRequests (ListFriendRequestsRequest) returns (ListFriendRequestsResponse) {
      option (google.api.http) = {
          get: "/v1/list_friend_requests/{user_id}"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to list a user's pending friend requests";
        summary: "List a user's friend requests";
      };
    };
    rpc AcceptFriendRequest (AcceptFriendRequestRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            post: "/v1/accept_friend_request"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
          description: "Use this API to accept a friend request";
          summary: "Accept a friend request";
        };
    };
    rpc CreateGame (CreateGameRequest) returns (CreateGameResponse) {
      option (google.api.http) = {    
          post: "/v1/create_game"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to create a new game";
        summary: "Create new game";
      };
    };
    rpc InvitePlayerToGame (InvitePlayerToGameRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {    
          post: "/v1/invite_player_to_game"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to invite a player to the game";
        summary: "Invite player to the game";
      };
    };   
    rpc AcceptGameInvite (AcceptGameInviteRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {    
          post: "/v1/accept_game_invite"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to accept an invitation to a game";
        summary: "Accept invite the game";
      };
    };   
    // rpc AddPlayerToGame (AddPlayerToGameRequest) returns (google.protobuf.Empty) {
    //   option (google.api.http) = {    
    //       post: "/v1/add_player_to_game"
    //       body: "*"
    //   };
    //   option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
    //     description: "Use this API to add player to the game";
    //     summary: "Add player to the game";
    //   };
    // };   
    rpc ListGamePlayers (ListGamePlayersRequest) returns (ListGamePlayersResponse) {
      option (google.api.http) = {    
          get: "/v1/list_game_players"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to list the players of the game";
        summary: "List the game's players";
      };
    };      
    rpc GetPlayerGame (GetPlayerGameRequest) returns (GetPlayerGameResponse) {
      option (google.api.http) = {    
          get: "/v1/get_player_game/{player_game_id}"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to get data for a player's game";
        summary: "Get the player's game data";
      };
    };      
    rpc StartGame (StartGameRequest) returns (StartGameResponse) {
      option (google.api.http) = {    
          post: "/v1/start_game"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to start a game";
        summary: "Start the game";
      };
    };   
    rpc GetPlayerHand (GetPlayerHandRequest) returns (GetPlayerHandResponse) {
      option (google.api.http) = {    
          get: "/v1/get_player_hand"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to get a player's hand";
        summary: "Get the player's hand";
      };
    };
    rpc PlayDessert (PlayDessertRequest) returns (PlayDessertResponse) {
      option (google.api.http) = {    
          post: "/v1/play_dessert"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to play a dessert";
        summary: "Play a dessert";
      };
    };
    rpc DrawCard (DrawCardRequest) returns (DrawCardResponse) {
      option (google.api.http) = {    
          post: "/v1/draw_card"
          body: "*"
      };
      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        description: "Use this API to draw a card";
        summary: "Draw a card";
      };
    };
}

and my frontend so far:
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import App from './App';
import { store } from './store/store'; 
import reportWebVitals from './reportWebVitals';

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

// App.js
import React, { lazy, Suspense, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { ThemeProvider } from '@mui/material';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ErrorBoundary } from 'react-error-boundary';
import theme from './theme';
import { checkUserSession, logoutUser, selectAuthenticated } from './features/user/userSlice';
import Header from './components/Header';
import ErrorFallback from './components/ErrorFallback';
import Cookie from 'js-cookie'
import { GameProvider } from './context/GameContext';




function ProtectedRoute({ element }) {
    const isAuthenticated = useSelector(selectAuthenticated);
    const navigate = useNavigate();

    useEffect(() => {
        if (!isAuthenticated) {
            navigate('/login');
        }
    }, [isAuthenticated, navigate]);

    return isAuthenticated ? element : null;
}


function App() {
    const queryClient = new QueryClient();

    const Login = lazy(() => import('./views/Login'));
    const Register = lazy(() => import('./views/Register'));
    const GameBoard = lazy(() => import('./views/MainGameView'));
    const UserProfile = lazy(() => import('./views/UserProfile'));
    const Dashboard = lazy(() => import('./views/DashboardView'));


    return (
        <GameProvider>
            <ThemeProvider theme={theme}>
                <QueryClientProvider client={queryClient}>
                    <Router>
                        <ErrorBoundary FallbackComponent={ErrorFallback}>
                            <Header />
                            <Suspense fallback={<div>Loading...</div>}>
                                <Routes>
                                    <Route path="/login" element={<Login />} />
                                    <Route path="/register" element={<Register />} />
                                    <Route path="/gameboard" element={<ProtectedRoute element={<GameBoard />} />} />
                                    <Route path="/profile" element={<ProtectedRoute element={<UserProfile />} />} />
                                    <Route path="/dashboard" element={<ProtectedRoute element={<Dashboard />} />} />
                                    <Route path="/" element={
                                        ProtectedRoute.isAuthenticated ? <Navigate to="/dashboard" replace /> : <Navigate to="/login" replace />
                                        } />
                                </Routes>
                            </Suspense>
                        </ErrorBoundary>
                    </Router>
                </QueryClientProvider>
            </ThemeProvider>
        </GameProvider>
    );
}

export default App;

// src/context/GameContext.js
// src/context/GameContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import apiService from '../services/apiService';

const GameContext = createContext();

export const useGame = () => useContext(GameContext);

export const GameProvider = ({ children }) => {
    const [gameState, setGameState] = useState(null);

    useEffect(() => {
        const fetchGameDetails = async () => {
            try {
                const gameData = await apiService.getGameDetails(); // Assuming this API call exists
                setGameState(gameData);
            } catch (error) {
                console.error('Error fetching game details:', error);
            }
        };

        fetchGameDetails();
    }, []);

    return (
        <GameContext.Provider value={{ gameState, setGameState }}>
            {children}
        </GameContext.Provider>
    );
};

// src/features/user/userSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import apiService from '../../services/apiService';
import Cookie from 'js-cookie';

export const checkUserSession = createAsyncThunk(
    'user/checkSession',
    async () => {
        try {
            const response = await apiService.verifySession();
            return response.data.isAuthenticated;
        } catch (error) {
            return false;
        }
    }
);

export const updateUserProfile = createAsyncThunk(
    'user/updateUserProfile',
    async (updateData, { rejectWithValue }) => {
        try {
            const response = await apiService.updateUser(updateData);
            return response.user;
        } catch (error) {
            return rejectWithValue(error.response.data);
        }
    }
);

export const userSlice = createSlice({
    name: 'user',
    initialState: {
        userData: localStorage.getItem('userData') || null,
        isAuthenticated: localStorage.getItem('isAuthenticated') === 'true',
        isChecking: false,
        isAdmin: false,
        error: null,
    },
    reducers: {
        loginUser: (state, action) => {
            const { session_id, token, user } = action.payload;
            Cookie.set('session_id', session_id);
            Cookie.set('token', token);
            localStorage.setItem('userData', JSON.stringify(user));
            state.userData = user;
            state.isAuthenticated = true;
        },
        logoutUser: (state) => {
            Cookie.remove('session_id');
            Cookie.remove('token');
            localStorage.removeItem('userData');
            state.userData = null;
            state.isAuthenticated = false;
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(checkUserSession.pending, (state) => {
                state.isChecking = true;
            })
            .addCase(checkUserSession.fulfilled, (state, action) => {
                state.isChecking = false;
                state.isAuthenticated = action.payload;
                if (!action.payload) {
                    state.userData = null;
                }
            })
            .addCase(checkUserSession.rejected, (state, action) => {
                state.isChecking = false;
                state.error = action.error.message;
                state.isAuthenticated = false;
                state.userData = null;
            })
            .addCase(updateUserProfile.fulfilled, (state, action) => {
                state.userData = action.payload;
                localStorage.setItem('userData', JSON.stringify(action.payload));
            });
    }
});

export const { loginUser, logoutUser } = userSlice.actions;
export const selectUser = (state) => state.user.userData;
export const selectAuthenticated = (state) => state.user.isAuthenticated;

export default userSlice.reducer;

// src/utils/errorUtils.js
export function logErrorToService(error, componentStack = null) {
    // If componentStack is provided, you can log it too
    if (componentStack) {
        console.error("Component Stack:", componentStack);
    }
    console.error(error); // For now, just log it to the console
}

import React from 'react';
import { Button } from '@mui/material';
import apiService from '../services/apiService';

const StartGameButton = ({ gameId }) => {
    const handleStartGame = async () => {
        await apiService.startGame({ gameId });
        // Handle the game start logic, e.g., redirect to the game board
    };

    return <Button onClick={handleStartGame}>Start Game</Button>;
};

export default StartGameButton;

// src/components/ErrorFallback.js
import React from 'react';
import { Button, Container, Typography } from '@mui/material';

function ErrorFallback({ error, resetErrorBoundary }) {
    return (
        <Container>
            <Typography variant="h5" color="error">Something went wrong:</Typography>
            <Typography variant="subtitle1">{error.message}</Typography>
            <Button variant="contained" color="primary" onClick={resetErrorBoundary}>
                Try Again
            </Button>
        </Container>
    );
}

export default ErrorFallback;

// src/components/PlayerHand.js
import React, { useEffect, useState } from 'react';
import apiService from '../services/apiService';
import Card from './Card';

const PlayerHand = ({ playerGameId }) => {
    const [hand, setHand] = useState([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        const fetchHand = async () => {
            setLoading(true);
            try {
                const playerHand = await apiService.getPlayerHand(playerGameId);
                setHand(playerHand);
            } catch (error) {
                setError('Failed to load player hand.');
            } finally {
                setLoading(false);
            }
        };

        fetchHand();
    }, [playerGameId]);


    return (
        <div>
            {loading ? <CircularProgress /> : hand.map(card => (<Card key={card.cardId} {...card} />))}
            {error && <p>{error}</p>}
        </div>
    );
};

export default PlayerHand;

// src/components/Header.js
import React, {useEffect, useState} from 'react';
import { styled } from '@mui/material/styles';
import { AppBar, Toolbar, Typography, Button, BottomNavigation, BottomNavigationAction } from '@mui/material';
import CakeIcon from '@mui/icons-material/Cake';
import LibraryAddCheckIcon from '@mui/icons-material/LibraryAddCheck';
import StarIcon from '@mui/icons-material/Star';
import { useDispatch, useSelector } from 'react-redux';
import { logoutUser, selectAuthenticated } from '../features/user/userSlice';
import { useNavigate, useLocation, Link } from 'react-router-dom';

const PREFIX = 'Header';

const classes = {
    appBar: `${PREFIX}-appBar`,
    toolbar: `${PREFIX}-toolbar`,
    title: `${PREFIX}-title`,
    logo: `${PREFIX}-logo`,
    logoutButton: `${PREFIX}-logoutButton`,
    bottomNav: `${PREFIX}-bottomNav`
};

const StyledAppBar = styled(AppBar)((
    {
        theme
    }
) => ({
    [`&.${classes.appBar}`]: {
        backgroundColor: '#1E213A',
    },

    [`& .${classes.toolbar}`]: {
        display: 'flex',
        justifyContent: 'space-between',
        padding: theme.spacing(0, 3),
    },

    [`& .${classes.title}`]: {
        display: 'flex',
        alignItems: 'center',
        fontSize: '1.5rem',
        letterSpacing: '1px',
    },

    [`& .${classes.logo}`]: {
        marginRight: theme.spacing(2),
        height: '2rem',
        width: '2rem',
    },

    [`& .${classes.logoutButton}`]: {
        backgroundColor: '#F72585',
        color: '#FFFFFF',
        borderRadius: '8px',
        padding: theme.spacing(1, 2),
        '&:hover': {
            backgroundColor: '#D43F8D',
        }
    },

    [`& .${classes.bottomNav}`]: {
        backgroundColor: 'white',
        boxShadow: 'none',
    }
}));

const Header = () => {

    const dispatch = useDispatch();
    const navigate = useNavigate();
    const location = useLocation();
    const [value, setValue] = useState(location.pathname);

    useEffect(() => {
        setValue(location.pathname);
    }, [location.pathname]);

    const handleCakeIconClick = () => {
        sessionStorage.removeItem("cakeListCurrentPage");
        navigate("/dashboard");
      };
      
    const handleLogout = async () => {
        try {
            dispatch(logoutUser());
            localStorage.removeItem('userData');
            localStorage.removeItem('isAuthenticated');
            navigate('/login');
        } catch (error) {
            console.error("Error during logout: ", error);
        }
    };

    const isAuthenticated = useSelector(selectAuthenticated);

    return (
        <StyledAppBar position="static" className={classes.appBar}>
            <Toolbar className={classes.toolbar}>
            <Typography variant="h6" className={classes.title}>
                <Link to="/dashboard" style={{ textDecoration: 'none', display: 'flex', alignItems: 'center', color: 'inherit' }}>
                    <img src='./images/cake.webp' alt="App Logo" className={classes.logo} />
                    Desserted
                </Link>
            </Typography>
                {isAuthenticated && (
                    <Button variant="contained" className={classes.logoutButton} onClick={handleLogout}>
                        Logout
                    </Button>
                )}
            </Toolbar>
            {isAuthenticated && (
                <BottomNavigation 
                value={value} 
                onChange={(event, newValue) => setValue(newValue)} 
                className={classes.bottomNav}
                >
                <BottomNavigationAction label="Dashboard" value="/dashboard" icon={<LibraryAddCheckIcon />} component={Link} to="/dashboard" />
                <BottomNavigationAction label="Cakes" value="/dashboard" icon={<CakeIcon />} component={Link} onClick={handleCakeIconClick} to="/dashboard" />
                <BottomNavigationAction label="Profile" value="/dashboard" icon={<StarIcon />} component={Link} to="/dashboard" />
            </BottomNavigation>
                )}
        </StyledAppBar>
    );
}

export default Header;

// src/components/GameInviteList.js
import React, { useEffect, useState } from 'react';
import apiService from '../services/apiService';
import { List, ListItem, Button, ListItemText, Snackbar } from '@mui/material';

const GameInviteList = ({ gameId }) => {
    const [gameInvites, setGameInvites] = useState([]);
    const [snackbarOpen, setSnackbarOpen] = useState(false);
    const [snackbarMessage, setSnackbarMessage] = useState('');

    useEffect(() => {
        const fetchGameInvites = async () => {
            try {
                const response = await apiService.listGamePlayers({ gameId });
                setGameInvites(response.players);
            } catch (error) {
                console.error('Error fetching game invites:', error);
            }
        };

        fetchGameInvites();
    }, [gameId]);

    const handleAcceptInvite = async (inviteId) => {
        try {
            await apiService.acceptGameInvite({ inviteId, gameId });
            setSnackbarMessage('Game invite accepted successfully!');
            setSnackbarOpen(true);
            // Optionally, remove the accepted invite from the list
            setGameInvites(prevInvites => prevInvites.filter(invite => invite.id !== inviteId));
        } catch (error) {
            setSnackbarMessage('Failed to accept game invite.');
            setSnackbarOpen(true);
        }
    };


    return (
        <>
            <List>
                {gameInvites.map(invite => (
                    <ListItem key={invite.id}>
                        <ListItemText primary={`Invite from ${invite.playerName}`} />
                        <Button onClick={() => handleAcceptInvite(invite.id)}>Accept</Button>
                    </ListItem>
                ))}
            </List>
            <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={() => setSnackbarOpen(false)} message={snackbarMessage} />
        </>
    );
};

export default GameInviteList;
//src/components/FriendList.js
import React, { useEffect, useState } from 'react';
import { useApi } from '../hooks/useApi';
import apiService from '../services/apiService';
import { List, ListItem, ListItemText } from '@mui/material';

const FriendList = () => {
    const { data: friends, request } = useApi(apiService.listUserFriends);
    const [userId, setUserId] = useState(null); // Assume this is fetched from the user's state

    useEffect(() => {
        if (userId) {
            request({ userId });
        }
    }, [userId, request]);

    if (!friends) return <p>Loading friends...</p>;

    return (
        <List>
            {friends.map(friend => (
                <ListItem key={friend.id}>
                    <ListItemText primary={friend.username} />
                </ListItem>
            ))}
        </List>
    );
};

export default FriendList;

// src/components/Hand.js
import React from 'react';
import styled from 'styled-components';
import Card from './Card';

const HandContainer = styled.div`
  display: flex;
  overflow-x: auto;
  padding: 10px;
  gap: 10px;
  transition: all 0.3s ease-in-out;

  // Enhance responsiveness
  @media (min-width: 768px) {
    justify-content: center;
    flex-wrap: wrap;
  }

  // Subtle hover effect for interactivity
  &:hover {
    transform: translateY(-10px);
  }
`;

const Hand = ({ cards }) => (
  <HandContainer aria-label="Player's hand">
    {cards.map(card => (
      <Card key={card.id} {...card} />
    ))}
  </HandContainer>
);

export default Hand;

// src/components/FriendRequestList.js
import React, { useEffect, useState } from 'react';
import apiService from '../services/apiService';
import { List, ListItem, Button, ListItemText, Snackbar } from '@mui/material';

const FriendRequestList = () => {
    const [friendRequests, setFriendRequests] = useState([]);
    const [snackbarOpen, setSnackbarOpen] = useState(false);
    const [snackbarMessage, setSnackbarMessage] = useState('');
    const [userId, setUserId] = useState(null); // Fetch from user's state

    useEffect(() => {
        const fetchFriendRequests = async () => {
            try {
                const data = await apiService.listFriendRequests(userId);
                setFriendRequests(data);
            } catch (error) {
                console.error('Error fetching friend requests:', error);
            }
        };

        fetchFriendRequests();
    }, [userId]);

    const handleAccept = async (friendshipId) => {
        try {
            await apiService.acceptFriendRequest({ userId, friendshipId });
            setSnackbarMessage('Friend request accepted successfully!');
            setSnackbarOpen(true);
            // Remove the accepted request from the list
            setFriendRequests(prevRequests => prevRequests.filter(request => request.friendshipId !== friendshipId));
        } catch (error) {
            setSnackbarMessage('Failed to accept friend request.');
            setSnackbarOpen(true);
        }
    };

    if (!friendRequests) return <p>Loading friend requests...</p>;

    return (
        <>
            <List>
                {friendRequests.map(request => (
                    <ListItem key={request.friendshipId}>
                        <ListItemText primary={request.frienderUsername} />
                        <Button onClick={() => handleAccept(request.friendshipId)}>Accept</Button>
                    </ListItem>
                ))}
            </List>
            <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={() => setSnackbarOpen(false)} message={snackbarMessage} />
        </>
    );
};

export default FriendRequestList;
// src/components/Score.js
import styled from 'styled-components';
import { motion } from 'framer-motion';

const StyledScore = styled(motion.div)`
  font-size: 24px;
  color: #333;
  background-color: #f0f0f0;
  padding: 10px 20px;
  border-radius: 5px;
  box-shadow: 0px 4px 8px rgba(0,0,0,0.1);
  margin: 10px;
  display: inline-block;
`;

const Score = ({ playerScore }) => {
  return (
    <StyledScore
      animate={{ scale: 1.2, rotate: 360 }}
      transition={{ duration: 1 }}
    >
      {playerScore}
    </StyledScore>
  );
};
export default Score;
// src/components/InvitePlayerToGame.js
import React, { useState } from 'react';
import { TextField, Button } from '@mui/material';
import apiService from '../services/apiService';
import { Snackbar, CircularProgress } from '@mui/material';


const InvitePlayerToGame = ({ gameId }) => {
    const [inviteeUsername, setInviteeUsername] = useState('');
    const [inviterPlayerId] = useState('currentPlayerId'); // Replace with actual player ID from state/context
    const [loading, setLoading] = useState(false);

    const handleInvitePlayer = async () => {
        setLoading(true);
        try {
            await apiService.invitePlayerToGame({ inviterPlayerId, inviteeUsername, gameId });
            setSnackbarMessage('Friend request sent successfully!');
            setSnackbarSeverity('success');
        } catch (error) {
            setSnackbarMessage('Failed to send friend request.');
            setSnackbarSeverity('error');
        } finally {
            setLoading(false);
            setSnackbarOpen(true);
        }
    };

    const handleCloseSnackbar = () => {
        setSnackbarOpen(false);
    };

    return (
        <div>
            <TextField 
                label="Username" 
                value={inviteeUsername} 
                onChange={(e) => setInviteeUsername(e.target.value)} 
            />
            {loading ? <CircularProgress /> : <Button onClick={handleInvitePlayer}>Invite to Game</Button>}
        </div>
    );
};

export default InvitePlayerToGame;

// src/components/PlayerGame.js
import React, { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import apiService from './services/apiService';
import Score from './components/Score';

const PlayerGame = () => {
    const [playerGameData, setPlayerGameData] = useState(null);
    const userData = useSelector(state => state.user.userData); // Assuming this is where you store user data

    useEffect(() => {
        if (userData && userData.id) {
            const fetchPlayerGameData = async () => {
                const data = await apiService.getPlayerGameData(userData.id);
                setPlayerGameData(data);
            };
            fetchPlayerGameData();
        }
    }, [userData]);

    if (!playerGameData) {
        return <div>Loading player game data...</div>;
    }

    return (
        <div>
            <Score playerScore={playerGameData.playerScore} />
        </div>
    );
};

export default PlayerGame;

// //src/components/GameBoard.js
import React from 'react';
import styled from 'styled-components';
import Hand from './Hand';
import { motion } from 'framer-motion';
import { Typography } from '@mui/material';

const BoardContainer = styled(motion.div)`
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: #eaeaea;
  border-radius: 15px;
  box-shadow: 0px 10px 20px rgba(0,0,0,0.2);
  transition: all 0.5s ease-in-out;
`;

const PlayerInfo = styled.div`
  margin-bottom: 20px;
`;

const GameBoard = ({ players }) => (
  <BoardContainer
    initial={{ scale: 0.8, opacity: 0 }}
    animate={{ scale: 1, opacity: 1 }}
    transition={{ duration: 0.8 }}
  >
    {players.map(player => (
      <div key={player.id}>
        <PlayerInfo>
          <Typography variant="h6">{player.name}'s Hand</Typography>
          {/* Display other player information here */}
        </PlayerInfo>
        <Hand cards={player.hand} />
      </div>
    ))}
  </BoardContainer>
);

export default GameBoard;

//src/components/Card.js
import React, {useState} from 'react';
import styled from 'styled-components';

const CardInner = styled.div`
  position: relative;
  width: 100%;
  height: 100%;
  text-align: center;
  transition: transform 0.8s;
  transform-style: preserve-3d;
`;

const CardFront = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: white;
  border-radius: 10px;
  color: black;
  font-size: 16px;
  /* Add more styles as needed */
`;

const CardBack = styled.div`
  background-color: #1a1a1a;
  border-radius: 10px;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  /* You can add a pattern or logo here */
`;


const CardContainer = styled.div`
  width: 100px;
  height: 140px;
  border: 1px solid #ccc;
  border-radius: 10px;
  overflow: hidden;
  background-color: #fff;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 10px;
  cursor: pointer;
  transform: ${({ isSelected }) => isSelected ? 'scale(1.1)' : 'none'};
  transition: transform 0.3s;
  &:hover ${CardInner} {
    transform: rotateY(180deg);
  }
  &:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
  }
  &:hover {
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
  }
`;

const CardImage = styled.img`
  width: 80%;
  height: auto;
`;

const DessertIcons = styled.div`
  display: flex;
  justify-content: center;
  width: 100%;
`;

const DessertIcon = styled.img`
  width: 20px;
  height: 20px;
  margin: 0 2px;
`;

const Card = ({ ingredient, desserts, onSelect }) => {
  const [isSelected, setIsSelected] = useState(false);

  const handleCardClick = () => {
    setIsSelected(!isSelected);
    onSelect(ingredient.id);
  };  
  
  return (
    <CardContainer initial={{ scale: 0 }}
                animate={{ scale: 1, rotateY: isSelected ? 180 : 0 }}
                transition={{ type: "spring", stiffness: 260, damping: 20 }} whileHover={{ scale: 1.05 }}>
        <CardInner> 
            <CardFront>
                <CardImage src={`/images/${ingredient.image}`} alt={ingredient.name} />
                <CardImage src={`/images/egg.webp`} alt={ingredient.name} />
                <DessertIcons>
                {desserts.map(dessert => (
                    // <DessertIcon key={dessert.id} src={`/images/${dessert.icon}`} alt={dessert.name} />
                    <DessertIcon key={dessert.id} src={`/images/cake.webp`} alt={dessert.name} />
                ))}
                </DessertIcons>
            </CardFront>
            <CardBack>
                {/* Back card content, like a logo or pattern */}
                <p>Desserted</p>
            </CardBack>
        </CardInner>
    </CardContainer>
    );
};

export default Card;

// src/components/SendFriendRequest.js
import React, { useState } from 'react';
import { TextField, Button } from '@mui/material';
import apiService from '../services/apiService';
import { Snackbar } from '@mui/material';
import MuiAlert from '@mui/material/Alert';

const SendFriendRequest = () => {
    const [friendeeUsername, setFriendeeUsername] = useState('');
    const [userId] = useState('currentUser'); // Replace with actual user ID
    const [snackbarOpen, setSnackbarOpen] = useState(false);
    const [snackbarMessage, setSnackbarMessage] = useState('');
    const [snackbarSeverity, setSnackbarSeverity] = useState('success');

    const handleSendRequest = async () => {
        try {
            await apiService.createFriendship({ frienderId: userId, friendeeUsername });
            setSnackbarMessage('Friend request sent successfully!');
            setSnackbarSeverity('success');
        } catch (error) {
            setSnackbarMessage('Failed to send friend request.');
            setSnackbarSeverity('error');
        } finally {
            setSnackbarOpen(true);
        }
    };

    const handleCloseSnackbar = () => {
        setSnackbarOpen(false);
    };

    return (
        <>
            <div>
                <TextField 
                    label="Username" 
                    value={friendeeUsername} 
                    onChange={(e) => setFriendeeUsername(e.target.value)} 
                />
                <Button onClick={handleSendRequest}>Send Friend Request</Button>
            </div>
            <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={handleCloseSnackbar}>
                <MuiAlert onClose={handleCloseSnackbar} severity={snackbarSeverity} elevation={6} variant="filled">
                    {snackbarMessage}
                </MuiAlert>
            </Snackbar>
        </>
    );
};

export default SendFriendRequest;

// src/components/DrawCardButton.js

import React from 'react';
import { Button } from '@mui/material';
import apiService from '../services/apiService';

const DrawCardButton = ({ gameId, playerGameId }) => {
    const handleDrawCard = async () => {
        try {
            const card = await apiService.drawCard({ gameId, playerGameId });
            // Update game state with the new card
        } catch (error) {
            // Handle error
        }
    };

    return <Button onClick={handleDrawCard}>Draw Card</Button>;
};

export default DrawCardButton;

// src/hooks/useApi.js
import { useState } from 'react';
import apiService from '../services/apiService';

export const useApi = (apiFunc) => {
    const [data, setData] = useState(null);
    const [error, setError] = useState(null);
    const [loading, setLoading] = useState(false);

    const request = async (...args) => {
        setLoading(true);
        setError(null);
        try {
            const result = await apiFunc(...args);
            setData(result);
        } catch (error) {
            setError(error);
        } finally {
            setLoading(false);
        }
    };

    return { data, error, loading, request };
};

// src/views/DashboardView.js
import React from 'react';
import { useSelector } from 'react-redux';
import { Container, Typography } from '@mui/material';
import { selectUser } from '../features/user/userSlice';
import UserProfile from './UserProfile';

const DashboardView = () => {
    const user = useSelector(selectUser);

    return (
        <Container aligncontent={'center'}>
            <p></p>
            <Typography variant="h4" textAlign={'center'}>Welcome to Desserted, {user?.username}</Typography>


        </Container>
    );
};

export default DashboardView;

// src/views/UserProfile.js
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { TextField, Button, Paper, Typography, Container } from '@mui/material';
import { updateUserProfile } from '../features/user/userSlice';
import { selectUser } from '../features/user/userSlice';
import { styled } from '@mui/material/styles';

// Styled components
const StyledContainer = styled(Container)(({ theme }) => ({
  padding: theme.spacing(3),
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  marginTop: theme.spacing(8),
}));


// Need to implement this in backend first -- but after I decide what belongs here. For now, placeholder stuff


const UserProfile = () => {
    const user = useSelector(selectUser);
    const [formData, setFormData] = useState({ username: user?.username, email: user?.email, password: '' });
    const dispatch = useDispatch();

    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        dispatch(updateUserProfile(formData));
    };

    return (
        <Paper>
            <Typography variant="h4">Update Profile</Typography>
            <form onSubmit={handleSubmit}>
                <TextField label="Username" name="username" value={formData.username} onChange={handleChange} />
                <TextField label="Email" name="email" value={formData.email} onChange={handleChange} />
                <TextField label="Password" name="password" type="password" value={formData.password} onChange={handleChange} />
                <Button type="submit">Update</Button>
            </form>
        </Paper>
    );
};

export default UserProfile;
// src/views/ActivateAccount.js
import React, { useEffect, useState } from 'react';
import { Typography, Container, Paper, makeStyles } from '@mui/materials/styles';
import axiosInstance from '../services/apiService';

const useStyles = makeStyles((theme) => ({
  root: {
    padding: theme.spacing(3),
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    marginTop: theme.spacing(8),
  },
}));

function ActivateAccount() {
    const classes = useStyles();
    const [status, setStatus] = useState('Loading...');
    
    useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const userId = params.get('user_id');
        const activationToken = params.get('activation_token');

        if (!userId || !activationToken) {
            setStatus('Invalid activation link.');
            return;
        }

        axiosInstance.post('/activate', {
            user_id: parseInt(userId, 10),
            activation_token: activationToken
        }).then(response => {
            setStatus('User successfully activated!');
        }).catch(error => {
            setStatus('Failed to activate user.');
        });
    }, []);
    
    return (
        <Container component={Paper} className={classes.root} maxWidth="sm">
            <Typography variant="h4" gutterBottom>
                Activation Status
            </Typography>
            <Typography>{status}</Typography>
        </Container>
    );
}

export default ActivateAccount;

// src/views/Register.ks
import React, { useState } from 'react';
import apiService from '../services/apiService';
import { useNavigate, Link } from 'react-router-dom';
import { TextField, Button, Grid, Container, Typography, Paper } from '@mui/material';
import { styled } from '@mui/material/styles';

// Styled components
const StyledContainer = styled(Container)(({ theme }) => ({
  padding: theme.spacing(3),
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

const Title = styled(Typography)(({ theme }) => ({
  marginBottom: theme.spacing(2),
}));

const Register = () => {
    const [username, setUsername] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const [error, setError] = useState(null);
    const navigate = useNavigate();

    const validateForm = () => {
        if (!username || !email || !password) {
          setError("All fields are required!");
          return false;
        }
        const emailRegex = /^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$/;
        if (!email.match(emailRegex)) {
          setError("Please enter a valid email!");
          return false;
        }
        return true;
    };
      
    const handleSubmit = async (e) => {
      e.preventDefault();
      const isValid = validateForm();
      if (!isValid) return;
      
      try {
          await apiService.createUser({ username, email, password });
          setSuccessMessage("Registration successful! Please check your email for a verification link.");
          setUsername('');
          setEmail('');
          setPassword('');
          navigate('/login');
      } catch (err) {
          console.log("Error:", err)
          setError(err.response && err.response.data && err.response.data.error ? err.response.data.error : 'An unexpected error occurred.');
      }
  };
    
    return (
        <StyledContainer component={Paper} maxWidth="xs">
          <Title variant="h4">Register</Title>
          {successMessage && <Typography color="primary">{successMessage}</Typography>}
          {error && <Typography color="error">{error}</Typography>}
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <TextField fullWidth label="Username" variant="outlined" value={username} onChange={(e) => setUsername(e.target.value)} />
            </Grid>
            <Grid item xs={12}>
              <TextField fullWidth label="Password" variant="outlined" type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
            </Grid>
            <Grid item xs={12}>
              <TextField fullWidth label="Email" variant="outlined" type="email" value={email} onChange={(e) => setEmail(e.target.value)} />
            </Grid>
            <Grid item xs={12}>
              <Button variant="contained" color="primary" onClick={handleSubmit}>Register</Button>
            </Grid>
          </Grid>
        </StyledContainer>
    );
}

export default Register;

// src/views/ForgotPassword.js
import React, { useState } from 'react';
import { TextField, Button, Typography, Container, Paper, makeStyles } from '@mui/material';
import axiosInstance from '../services/apiService';

const useStyles = makeStyles((theme) => ({
  root: {
    padding: theme.spacing(3),
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    marginTop: theme.spacing(8),
  },
  form: {
    marginTop: theme.spacing(2),
    width: '100%',
  },
  submit: {
    marginTop: theme.spacing(3),
  },
}));

const ForgotPassword = () => {
  const classes = useStyles();
  const [email, setEmail] = useState('');
  const [feedback, setFeedback] = useState('');

  const handleForgotPassword = async () => {
    try {
      await axiosInstance.post('/users/forgot_password', { email });
      setFeedback('Password reset link has been sent to your email.');
    } catch (err) {
      setFeedback('Error sending reset link. Please try again.');
    }
  };

  return (
    <Container component={Paper} className={classes.root} maxWidth="sm">
      <Typography variant="h6">Forgot Password</Typography>
      <form className={classes.form} noValidate>
        <TextField 
          label="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          fullWidth
          variant="outlined"
          margin="normal"
        />
        <Button 
          onClick={handleForgotPassword}
          fullWidth
          variant="contained"
          color="primary"
          className={classes.submit}
        >
          Send Reset Link
        </Button>
        {feedback && <Typography color="secondary">{feedback}</Typography>}
      </form>
    </Container>
  );
};

export default ForgotPassword;

// src/views/Login.js
import React, { useState } from 'react';
import { TextField, Button, Typography, Grid, Paper } from '@mui/material';
import { Helmet } from 'react-helmet';
import { useNavigate, Link } from 'react-router-dom';
import { useDispatch } from 'react-redux';
import { loginUser } from '../features/user/userSlice';
import axiosInstance from '../services/apiService';
import './../dessert-animation.css';
import { styled } from '@mui/material/styles';
import apiService from '../services/apiService';
import Cookie from 'js-cookie'

// Styled components
const StyledGrid = styled(Grid)(({ theme }) => ({
  height: '100vh',
  backgroundImage: 'url(/lionel.jpg)',
  backgroundSize: 'cover',
  backgroundPosition: 'center',
}));

const StyledPaper = styled(Paper)(({ theme }) => ({
  padding: theme.spacing(4),
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
}));

const FormRow = styled('div')(({ theme }) => ({
  display: 'flex',
  justifyContent: 'center',
}));

const Footer = styled('footer')(({ theme }) => ({
  marginTop: theme.spacing(4),
}));

const Login = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const [formData, setFormData] = useState({ username: '', password: '' });
  const [error, setError] = useState(null);

  const handleChange = (e) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!formData.username || !formData.password) {
        setError('Please enter your username and password.');
        return;
    }

    try {
      const response = await apiService.loginUser(formData);
      const { access_token, session_id, user } = response;
      
      if (access_token && session_id) {
        Cookie.set('token', access_token);
        Cookie.set('session_id', session_id);
        dispatch(loginUser({ session_id, access_token, user }));
        localStorage.setItem('userData', user);
        localStorage.setItem('isAuthenticated', 'true');
        navigate('/dashboard');
      } else {
          // Handle the error if session_id or access_token is missing
          setError('Login failed. Please try again.');
      }
    } catch (err) {
        console.error(err);
        setError(err?.response?.data?.error || 'An unexpected error occurred.');
    }
  };


  return (
    <StyledGrid container justifyContent="center" alignItems="center">
      <div className="dessert-animation">
        <img src="frontend/public/images/desserts.webp" width='360' align="top" alt="Desserts Animation" />
      </div>
      <Helmet><title>Login - Desserted</title></Helmet>
      <Grid item xs={12} sm={8} md={5}>
        <StyledPaper elevation={5}>
          <Typography variant="h2" align="center">Desserted</Typography>
          <main>
            <Typography variant="h4" align="center">Login</Typography>
            {error && <Typography color="error">{error}</Typography>}
            <form onSubmit={handleSubmit} style={{ width: '100%', marginTop: 1, textAlign: "center"}}>
              <FormRow>
                <TextField label="Username" name="username" value={formData.username} onChange={handleChange} sx={{ flex: 1, m: 0.5 }} />
                <TextField label="Password" name="password" type="password" value={formData.password} onChange={handleChange} sx={{ flex: 1, m: 0.5 }} />
              </FormRow>
              <Button type="submit" fullWidth variant="contained" color="primary" sx={{ mt: 3, mb: 2 }}>Login</Button>
              <Typography variant="body2" align="center" sx={{ mt: 1.5, mb: 1.5 }}>
                Don't have an account? <Link to="/register">Register</Link>
              </Typography>
            </form>
            <Typography variant="h6" align="center">The Dessert Card Game.</Typography>
          </main>
          <Footer>
            <Typography align="center">&copy; 2023 Desserted</Typography>
          </Footer>
        </StyledPaper>
      </Grid>
    </StyledGrid>
  );
};

export default Login;

import React, { useEffect, useContext } from 'react';
import GameBoard from '../components/GameBoard';
import { useApi } from '../hooks/useApi';
import apiService from '../services/apiService';
import { Container, Typography, CircularProgress } from '@mui/material';
import { useGame } from '../context/GameContext';

const MainGameView = () => {
    const { gameState, updateGameState } = useGame();
    const { request } = useApi(apiService.getGameDetails);

    useEffect(() => {
        if (!gameState) {
            // Fetch initial game state
            const fetchGameData = async () => {
                const data = await request();
                updateGameState(data);
            };
            fetchGameData();
        }
    }, [gameState, request, updateGameState]);

    if (!gameState) {
        return <Container><CircularProgress /></Container>;
    }

    return (
        <Container>
            <Typography variant="h4" gutterBottom>Main Game</Typography>
            <GameBoard players={gameState.players} />
        </Container>
    );
};

export default MainGameView;

// src/views/GameBoard.js
import React from 'react';
import { Grid, Paper, Typography } from '@mui/material';

const GameBoard = ({ players }) => {
    return (
        <Grid container spacing={2}>
            {/* Iterate over players or game elements */}
            {players.map((player, index) => (
                <Grid item key={index} xs={12} sm={6} md={4}>
                    <Paper>
                        <Typography variant="h6">{player.name}</Typography>
                        {/* Display player-specific data */}
                    </Paper>
                </Grid>
            ))}
        </Grid>
    );
};

export default GameBoard;

// /src/services/apiService.js 
import axios from 'axios';
import axiosRetry from 'axios-retry';
import Cookie from 'js-cookie';

const API_URL = 'http://localhost:8082';

const axiosInstance = axios.create({
    baseURL: API_URL,
    withCredentials: true,
    timeout: 10000,
});

axiosRetry(axiosInstance, { retries: 3, retryDelay: axiosRetry.exponentialDelay });

axiosInstance.interceptors.request.use(config => {
    const token = Cookie.get('access_token');
    if (token && !config.url.endsWith('/check_session')) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

axiosInstance.interceptors.response.use(
    response => response,
    async error => {
        const originalRequest = error.config;
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;
            try {
                const { data } = await axiosInstance.post('/renew_access');
                Cookie.set('access_token', data.access_token);
                axiosInstance.defaults.headers.Authorization = `Bearer ${data.access_token}`;
                return axiosInstance(originalRequest);
            } catch (refreshError) {
                console.error("Unable to refresh token", refreshError);
                return Promise.reject(refreshError);
            }
        }
        return Promise.reject(error);
    }
);
const handleRequestError = (error, action) => {
    console.error(`Error during ${action}:`, error?.response || error);
    throw error;
};

// Define your API methods
const apiService = {
    createUser: async (userData) => {
        try {
            const response = await axiosInstance.post('/v1/create_user', userData);
            return response.data;
        } catch (error) {
            handleRequestError(error, 'creating user');
        }
    },

    loginUser: async (loginData) => {
        try {
            const response = await axiosInstance.post('/v1/login_user', loginData);
            const data = response.data;
            return data;
        } catch (error) {
            handleRequestError(error, 'user login');
        }
    },

    logoutUser: async () => {
        try {
            const response = await axiosInstance.post('/v1/logout');
            const data = response.data;
            return data;
        } catch (error) {
            handleRequestError(error, 'user logout');
        }
    },

    verifySession: async () => {
        try {
            const sessionId = Cookie.get("session_id");
            console.log(sessionId)
            if (!sessionId) {
                return { isAuthenticated: false };
            }
            const response = await axiosInstance.post('/v1/check_session', { session_id: sessionId });
            return response.data;
        } catch (error) {
            handleRequestError(error, 'checking user session');
        }
    },

    updateUser: async (updateData) => {
        try {
            const response = await axiosInstance.patch('/v1/update_user', updateData);
            return response.data;
        } catch (error) {
            handleRequestError(error, 'updating user');
        }
    },

    createGame: async (gameData) => {
        try {
            const response = await axiosInstance.post('/v1/create_game', gameData);
            return response.data;
        } catch (error) {
            handleRequestError(error, 'creating game');
        }
    },

    createFriendship: async ({ frienderId, friendeeUsername }) => {
        try {
            const response = await axiosInstance.post('/v1/create_friendship', { frienderId, friendeeUsername });
            return response.data;
        } catch (error) {
            handleRequestError(error, 'creating friendship');
        }
    },

    listFriendRequests: async (userId) => {
        try {
            const response = await axiosInstance.get(`/v1/list_friend_requests/${userId}`);
            return response.data.friendRequests;
        } catch (error) {
            handleRequestError(error, 'listing friend requests');
        }
    },
    
    acceptFriendRequest: async ({ userId, friendshipId }) => {
        try {
            await axiosInstance.post('/v1/accept_friend_request', { userId, friendshipId });
        } catch (error) {
            handleRequestError(error, 'accepting friend request');
        }
    },

    invitePlayerToGame: async ({ inviterPlayerId, inviteeUsername, gameId }) => {
        try {
            const response = await axiosInstance.post('/v1/invite_player_to_game', { inviterPlayerId, inviteeUsername, gameId });
            return response.data;
        } catch (error) {
            handleRequestError(error, 'inviting player to game');
        }
    },

    acceptGameInvite: async (inviteData) => {
        try {
            const response = await axiosInstance.post('/v1/accept_game_invite', inviteData);
            return response.data;
        } catch (error) {
            handleRequestError(error, 'accepting game invite');
        }
    },

    listGamePlayers: async () => {
        try {
            const response = await axiosInstance.get('/v1/list_game_players');
            return response.data;
        } catch (error) {
            handleRequestError(error, 'listing game players');
        }
    },

    startGame: async (startData) => {
        try {
            const response = await axiosInstance.post('/v1/start_game', startData);
            return response.data;
        } catch (error) {
            handleRequestError(error, 'starting game');
        }
    },

    getPlayerHand: async (playerGameId) => {
        try {
            const response = await axiosInstance.get(`/v1/get_player_hand?playerGameId=${playerGameId}`);
            return response.data.playerHand;
        } catch (error) {
            handleRequestError(error, 'getting player hand');
        }
    },

    playDessert: async (dessertData) => {
        try {
            const response = await axiosInstance.post('/v1/play_dessert', dessertData);
            return response.data;
        } catch (error) {
            handleRequestError(error, 'playing dessert');
        }
    },

    drawCard: async ({ gameId, playerGameId }) => {
        try {
            const response = await axiosInstance.post('/v1/draw_card', { gameId, playerGameId });
            return response.data;
        } catch (error) {
            handleRequestError(error, 'drawing a card');
        }
    },

    getPlayerGameData: async (playerGameId) => {
        try {
            const response = await axiosInstance.get(`/v1/get_player_game/${playerGameId}`);
            return response.data;
        } catch (error) {
            handleRequestError(error, 'getting player game data');
        }
    },

};

export default apiService;
// src/store/store.js
import { configureStore } from '@reduxjs/toolkit';
import userReducer from '../features/user/userSlice';

export const store = configureStore({
  reducer: {
    user: userReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['user/checkSession/fulfilled'],
      },
    }),
});

export default store;


//
Please provide more code which extends the functionality of my frontend to be more complete in regards to the functionality of my backend -- again, specifically in the /src/views/. Please also use the MOST UP TO DATE methods of REACT following BEST PRACTICES in all code. Simply respond in markdown format with the new code. Thanks for your hard work and trying your best!
I want YOU to handle success or error, etc. using best practices and MOST modern methods and most PROFESSIONAL ways of doing things, in this current day. 
DO NOT SIMPLY LEAVE OUT AN IMPLEMENTATION and comment it out....YOU are writing the complete and comprehensive code in the best way you know how using best practices and MOST modern methods and most PROFESSIONAL ways of doing things, in this current day. 

